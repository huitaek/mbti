// package: typedb.protocol
// file: common/answer.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";
import * as common_concept_pb from "../common/concept_pb";

export class ConceptMap extends jspb.Message { 

    getMapMap(): jspb.Map<string, common_concept_pb.Concept>;
    clearMapMap(): void;

    hasExplainables(): boolean;
    clearExplainables(): void;
    getExplainables(): Explainables | undefined;
    setExplainables(value?: Explainables): ConceptMap;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ConceptMap.AsObject;
    static toObject(includeInstance: boolean, msg: ConceptMap): ConceptMap.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ConceptMap, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ConceptMap;
    static deserializeBinaryFromReader(message: ConceptMap, reader: jspb.BinaryReader): ConceptMap;
}

export namespace ConceptMap {
    export type AsObject = {

        mapMap: Array<[string, common_concept_pb.Concept.AsObject]>,
        explainables?: Explainables.AsObject,
    }
}

export class Explainables extends jspb.Message { 

    getRelationsMap(): jspb.Map<string, Explainable>;
    clearRelationsMap(): void;

    getAttributesMap(): jspb.Map<string, Explainable>;
    clearAttributesMap(): void;

    getOwnershipsMap(): jspb.Map<string, Explainables.Owned>;
    clearOwnershipsMap(): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Explainables.AsObject;
    static toObject(includeInstance: boolean, msg: Explainables): Explainables.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Explainables, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Explainables;
    static deserializeBinaryFromReader(message: Explainables, reader: jspb.BinaryReader): Explainables;
}

export namespace Explainables {
    export type AsObject = {

        relationsMap: Array<[string, Explainable.AsObject]>,

        attributesMap: Array<[string, Explainable.AsObject]>,

        ownershipsMap: Array<[string, Explainables.Owned.AsObject]>,
    }


    export class Owned extends jspb.Message { 

        getOwnedMap(): jspb.Map<string, Explainable>;
        clearOwnedMap(): void;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Owned.AsObject;
        static toObject(includeInstance: boolean, msg: Owned): Owned.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Owned, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Owned;
        static deserializeBinaryFromReader(message: Owned, reader: jspb.BinaryReader): Owned;
    }

    export namespace Owned {
        export type AsObject = {

            ownedMap: Array<[string, Explainable.AsObject]>,
        }
    }

}

export class Explainable extends jspb.Message { 
    getConjunction(): string;
    setConjunction(value: string): Explainable;
    getId(): number;
    setId(value: number): Explainable;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Explainable.AsObject;
    static toObject(includeInstance: boolean, msg: Explainable): Explainable.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Explainable, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Explainable;
    static deserializeBinaryFromReader(message: Explainable, reader: jspb.BinaryReader): Explainable;
}

export namespace Explainable {
    export type AsObject = {
        conjunction: string,
        id: number,
    }
}

export class ConceptMapGroup extends jspb.Message { 

    hasOwner(): boolean;
    clearOwner(): void;
    getOwner(): common_concept_pb.Concept | undefined;
    setOwner(value?: common_concept_pb.Concept): ConceptMapGroup;
    clearConceptMapsList(): void;
    getConceptMapsList(): Array<ConceptMap>;
    setConceptMapsList(value: Array<ConceptMap>): ConceptMapGroup;
    addConceptMaps(value?: ConceptMap, index?: number): ConceptMap;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ConceptMapGroup.AsObject;
    static toObject(includeInstance: boolean, msg: ConceptMapGroup): ConceptMapGroup.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ConceptMapGroup, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ConceptMapGroup;
    static deserializeBinaryFromReader(message: ConceptMapGroup, reader: jspb.BinaryReader): ConceptMapGroup;
}

export namespace ConceptMapGroup {
    export type AsObject = {
        owner?: common_concept_pb.Concept.AsObject,
        conceptMapsList: Array<ConceptMap.AsObject>,
    }
}

export class Numeric extends jspb.Message { 

    hasLongValue(): boolean;
    clearLongValue(): void;
    getLongValue(): number;
    setLongValue(value: number): Numeric;

    hasDoubleValue(): boolean;
    clearDoubleValue(): void;
    getDoubleValue(): number;
    setDoubleValue(value: number): Numeric;

    hasNan(): boolean;
    clearNan(): void;
    getNan(): boolean;
    setNan(value: boolean): Numeric;

    getValueCase(): Numeric.ValueCase;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Numeric.AsObject;
    static toObject(includeInstance: boolean, msg: Numeric): Numeric.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Numeric, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Numeric;
    static deserializeBinaryFromReader(message: Numeric, reader: jspb.BinaryReader): Numeric;
}

export namespace Numeric {
    export type AsObject = {
        longValue: number,
        doubleValue: number,
        nan: boolean,
    }

    export enum ValueCase {
        VALUE_NOT_SET = 0,
        LONG_VALUE = 1,
        DOUBLE_VALUE = 2,
        NAN = 3,
    }

}

export class NumericGroup extends jspb.Message { 

    hasOwner(): boolean;
    clearOwner(): void;
    getOwner(): common_concept_pb.Concept | undefined;
    setOwner(value?: common_concept_pb.Concept): NumericGroup;

    hasNumber(): boolean;
    clearNumber(): void;
    getNumber(): Numeric | undefined;
    setNumber(value?: Numeric): NumericGroup;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): NumericGroup.AsObject;
    static toObject(includeInstance: boolean, msg: NumericGroup): NumericGroup.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: NumericGroup, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): NumericGroup;
    static deserializeBinaryFromReader(message: NumericGroup, reader: jspb.BinaryReader): NumericGroup;
}

export namespace NumericGroup {
    export type AsObject = {
        owner?: common_concept_pb.Concept.AsObject,
        number?: Numeric.AsObject,
    }
}
