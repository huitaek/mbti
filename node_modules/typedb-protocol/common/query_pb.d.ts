// package: typedb.protocol
// file: common/query.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";
import * as common_answer_pb from "../common/answer_pb";
import * as common_logic_pb from "../common/logic_pb";
import * as common_options_pb from "../common/options_pb";

export class QueryManager extends jspb.Message { 

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): QueryManager.AsObject;
    static toObject(includeInstance: boolean, msg: QueryManager): QueryManager.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: QueryManager, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): QueryManager;
    static deserializeBinaryFromReader(message: QueryManager, reader: jspb.BinaryReader): QueryManager;
}

export namespace QueryManager {
    export type AsObject = {
    }


    export class Req extends jspb.Message { 

        hasOptions(): boolean;
        clearOptions(): void;
        getOptions(): common_options_pb.Options | undefined;
        setOptions(value?: common_options_pb.Options): Req;

        hasDefineReq(): boolean;
        clearDefineReq(): void;
        getDefineReq(): QueryManager.Define.Req | undefined;
        setDefineReq(value?: QueryManager.Define.Req): Req;

        hasUndefineReq(): boolean;
        clearUndefineReq(): void;
        getUndefineReq(): QueryManager.Undefine.Req | undefined;
        setUndefineReq(value?: QueryManager.Undefine.Req): Req;

        hasMatchReq(): boolean;
        clearMatchReq(): void;
        getMatchReq(): QueryManager.Match.Req | undefined;
        setMatchReq(value?: QueryManager.Match.Req): Req;

        hasMatchAggregateReq(): boolean;
        clearMatchAggregateReq(): void;
        getMatchAggregateReq(): QueryManager.MatchAggregate.Req | undefined;
        setMatchAggregateReq(value?: QueryManager.MatchAggregate.Req): Req;

        hasMatchGroupReq(): boolean;
        clearMatchGroupReq(): void;
        getMatchGroupReq(): QueryManager.MatchGroup.Req | undefined;
        setMatchGroupReq(value?: QueryManager.MatchGroup.Req): Req;

        hasMatchGroupAggregateReq(): boolean;
        clearMatchGroupAggregateReq(): void;
        getMatchGroupAggregateReq(): QueryManager.MatchGroupAggregate.Req | undefined;
        setMatchGroupAggregateReq(value?: QueryManager.MatchGroupAggregate.Req): Req;

        hasInsertReq(): boolean;
        clearInsertReq(): void;
        getInsertReq(): QueryManager.Insert.Req | undefined;
        setInsertReq(value?: QueryManager.Insert.Req): Req;

        hasDeleteReq(): boolean;
        clearDeleteReq(): void;
        getDeleteReq(): QueryManager.Delete.Req | undefined;
        setDeleteReq(value?: QueryManager.Delete.Req): Req;

        hasUpdateReq(): boolean;
        clearUpdateReq(): void;
        getUpdateReq(): QueryManager.Update.Req | undefined;
        setUpdateReq(value?: QueryManager.Update.Req): Req;

        hasExplainReq(): boolean;
        clearExplainReq(): void;
        getExplainReq(): QueryManager.Explain.Req | undefined;
        setExplainReq(value?: QueryManager.Explain.Req): Req;

        getReqCase(): Req.ReqCase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Req.AsObject;
        static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Req;
        static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
    }

    export namespace Req {
        export type AsObject = {
            options?: common_options_pb.Options.AsObject,
            defineReq?: QueryManager.Define.Req.AsObject,
            undefineReq?: QueryManager.Undefine.Req.AsObject,
            matchReq?: QueryManager.Match.Req.AsObject,
            matchAggregateReq?: QueryManager.MatchAggregate.Req.AsObject,
            matchGroupReq?: QueryManager.MatchGroup.Req.AsObject,
            matchGroupAggregateReq?: QueryManager.MatchGroupAggregate.Req.AsObject,
            insertReq?: QueryManager.Insert.Req.AsObject,
            deleteReq?: QueryManager.Delete.Req.AsObject,
            updateReq?: QueryManager.Update.Req.AsObject,
            explainReq?: QueryManager.Explain.Req.AsObject,
        }

        export enum ReqCase {
            REQ_NOT_SET = 0,
            DEFINE_REQ = 100,
            UNDEFINE_REQ = 101,
            MATCH_REQ = 102,
            MATCH_AGGREGATE_REQ = 103,
            MATCH_GROUP_REQ = 104,
            MATCH_GROUP_AGGREGATE_REQ = 105,
            INSERT_REQ = 106,
            DELETE_REQ = 107,
            UPDATE_REQ = 108,
            EXPLAIN_REQ = 109,
        }

    }

    export class Res extends jspb.Message { 

        hasDefineRes(): boolean;
        clearDefineRes(): void;
        getDefineRes(): QueryManager.Define.Res | undefined;
        setDefineRes(value?: QueryManager.Define.Res): Res;

        hasUndefineRes(): boolean;
        clearUndefineRes(): void;
        getUndefineRes(): QueryManager.Undefine.Res | undefined;
        setUndefineRes(value?: QueryManager.Undefine.Res): Res;

        hasMatchAggregateRes(): boolean;
        clearMatchAggregateRes(): void;
        getMatchAggregateRes(): QueryManager.MatchAggregate.Res | undefined;
        setMatchAggregateRes(value?: QueryManager.MatchAggregate.Res): Res;

        hasDeleteRes(): boolean;
        clearDeleteRes(): void;
        getDeleteRes(): QueryManager.Delete.Res | undefined;
        setDeleteRes(value?: QueryManager.Delete.Res): Res;

        getResCase(): Res.ResCase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Res.AsObject;
        static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Res;
        static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
    }

    export namespace Res {
        export type AsObject = {
            defineRes?: QueryManager.Define.Res.AsObject,
            undefineRes?: QueryManager.Undefine.Res.AsObject,
            matchAggregateRes?: QueryManager.MatchAggregate.Res.AsObject,
            deleteRes?: QueryManager.Delete.Res.AsObject,
        }

        export enum ResCase {
            RES_NOT_SET = 0,
            DEFINE_RES = 100,
            UNDEFINE_RES = 101,
            MATCH_AGGREGATE_RES = 102,
            DELETE_RES = 104,
        }

    }

    export class ResPart extends jspb.Message { 

        hasMatchResPart(): boolean;
        clearMatchResPart(): void;
        getMatchResPart(): QueryManager.Match.ResPart | undefined;
        setMatchResPart(value?: QueryManager.Match.ResPart): ResPart;

        hasMatchGroupResPart(): boolean;
        clearMatchGroupResPart(): void;
        getMatchGroupResPart(): QueryManager.MatchGroup.ResPart | undefined;
        setMatchGroupResPart(value?: QueryManager.MatchGroup.ResPart): ResPart;

        hasMatchGroupAggregateResPart(): boolean;
        clearMatchGroupAggregateResPart(): void;
        getMatchGroupAggregateResPart(): QueryManager.MatchGroupAggregate.ResPart | undefined;
        setMatchGroupAggregateResPart(value?: QueryManager.MatchGroupAggregate.ResPart): ResPart;

        hasInsertResPart(): boolean;
        clearInsertResPart(): void;
        getInsertResPart(): QueryManager.Insert.ResPart | undefined;
        setInsertResPart(value?: QueryManager.Insert.ResPart): ResPart;

        hasUpdateResPart(): boolean;
        clearUpdateResPart(): void;
        getUpdateResPart(): QueryManager.Update.ResPart | undefined;
        setUpdateResPart(value?: QueryManager.Update.ResPart): ResPart;

        hasExplainResPart(): boolean;
        clearExplainResPart(): void;
        getExplainResPart(): QueryManager.Explain.ResPart | undefined;
        setExplainResPart(value?: QueryManager.Explain.ResPart): ResPart;

        getResCase(): ResPart.ResCase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): ResPart.AsObject;
        static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): ResPart;
        static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
    }

    export namespace ResPart {
        export type AsObject = {
            matchResPart?: QueryManager.Match.ResPart.AsObject,
            matchGroupResPart?: QueryManager.MatchGroup.ResPart.AsObject,
            matchGroupAggregateResPart?: QueryManager.MatchGroupAggregate.ResPart.AsObject,
            insertResPart?: QueryManager.Insert.ResPart.AsObject,
            updateResPart?: QueryManager.Update.ResPart.AsObject,
            explainResPart?: QueryManager.Explain.ResPart.AsObject,
        }

        export enum ResCase {
            RES_NOT_SET = 0,
            MATCH_RES_PART = 100,
            MATCH_GROUP_RES_PART = 101,
            MATCH_GROUP_AGGREGATE_RES_PART = 102,
            INSERT_RES_PART = 103,
            UPDATE_RES_PART = 104,
            EXPLAIN_RES_PART = 105,
        }

    }

    export class Match extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Match.AsObject;
        static toObject(includeInstance: boolean, msg: Match): Match.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Match, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Match;
        static deserializeBinaryFromReader(message: Match, reader: jspb.BinaryReader): Match;
    }

    export namespace Match {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class ResPart extends jspb.Message { 
            clearAnswersList(): void;
            getAnswersList(): Array<common_answer_pb.ConceptMap>;
            setAnswersList(value: Array<common_answer_pb.ConceptMap>): ResPart;
            addAnswers(value?: common_answer_pb.ConceptMap, index?: number): common_answer_pb.ConceptMap;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): ResPart.AsObject;
            static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): ResPart;
            static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
        }

        export namespace ResPart {
            export type AsObject = {
                answersList: Array<common_answer_pb.ConceptMap.AsObject>,
            }
        }

    }

    export class MatchAggregate extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): MatchAggregate.AsObject;
        static toObject(includeInstance: boolean, msg: MatchAggregate): MatchAggregate.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: MatchAggregate, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): MatchAggregate;
        static deserializeBinaryFromReader(message: MatchAggregate, reader: jspb.BinaryReader): MatchAggregate;
    }

    export namespace MatchAggregate {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class Res extends jspb.Message { 

            hasAnswer(): boolean;
            clearAnswer(): void;
            getAnswer(): common_answer_pb.Numeric | undefined;
            setAnswer(value?: common_answer_pb.Numeric): Res;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
                answer?: common_answer_pb.Numeric.AsObject,
            }
        }

    }

    export class MatchGroup extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): MatchGroup.AsObject;
        static toObject(includeInstance: boolean, msg: MatchGroup): MatchGroup.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: MatchGroup, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): MatchGroup;
        static deserializeBinaryFromReader(message: MatchGroup, reader: jspb.BinaryReader): MatchGroup;
    }

    export namespace MatchGroup {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class ResPart extends jspb.Message { 
            clearAnswersList(): void;
            getAnswersList(): Array<common_answer_pb.ConceptMapGroup>;
            setAnswersList(value: Array<common_answer_pb.ConceptMapGroup>): ResPart;
            addAnswers(value?: common_answer_pb.ConceptMapGroup, index?: number): common_answer_pb.ConceptMapGroup;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): ResPart.AsObject;
            static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): ResPart;
            static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
        }

        export namespace ResPart {
            export type AsObject = {
                answersList: Array<common_answer_pb.ConceptMapGroup.AsObject>,
            }
        }

    }

    export class MatchGroupAggregate extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): MatchGroupAggregate.AsObject;
        static toObject(includeInstance: boolean, msg: MatchGroupAggregate): MatchGroupAggregate.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: MatchGroupAggregate, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): MatchGroupAggregate;
        static deserializeBinaryFromReader(message: MatchGroupAggregate, reader: jspb.BinaryReader): MatchGroupAggregate;
    }

    export namespace MatchGroupAggregate {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class ResPart extends jspb.Message { 
            clearAnswersList(): void;
            getAnswersList(): Array<common_answer_pb.NumericGroup>;
            setAnswersList(value: Array<common_answer_pb.NumericGroup>): ResPart;
            addAnswers(value?: common_answer_pb.NumericGroup, index?: number): common_answer_pb.NumericGroup;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): ResPart.AsObject;
            static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): ResPart;
            static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
        }

        export namespace ResPart {
            export type AsObject = {
                answersList: Array<common_answer_pb.NumericGroup.AsObject>,
            }
        }

    }

    export class Explain extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Explain.AsObject;
        static toObject(includeInstance: boolean, msg: Explain): Explain.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Explain, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Explain;
        static deserializeBinaryFromReader(message: Explain, reader: jspb.BinaryReader): Explain;
    }

    export namespace Explain {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getExplainableId(): number;
            setExplainableId(value: number): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                explainableId: number,
            }
        }

        export class ResPart extends jspb.Message { 
            clearExplanationsList(): void;
            getExplanationsList(): Array<common_logic_pb.Explanation>;
            setExplanationsList(value: Array<common_logic_pb.Explanation>): ResPart;
            addExplanations(value?: common_logic_pb.Explanation, index?: number): common_logic_pb.Explanation;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): ResPart.AsObject;
            static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): ResPart;
            static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
        }

        export namespace ResPart {
            export type AsObject = {
                explanationsList: Array<common_logic_pb.Explanation.AsObject>,
            }
        }

    }

    export class Insert extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Insert.AsObject;
        static toObject(includeInstance: boolean, msg: Insert): Insert.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Insert, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Insert;
        static deserializeBinaryFromReader(message: Insert, reader: jspb.BinaryReader): Insert;
    }

    export namespace Insert {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class ResPart extends jspb.Message { 
            clearAnswersList(): void;
            getAnswersList(): Array<common_answer_pb.ConceptMap>;
            setAnswersList(value: Array<common_answer_pb.ConceptMap>): ResPart;
            addAnswers(value?: common_answer_pb.ConceptMap, index?: number): common_answer_pb.ConceptMap;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): ResPart.AsObject;
            static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): ResPart;
            static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
        }

        export namespace ResPart {
            export type AsObject = {
                answersList: Array<common_answer_pb.ConceptMap.AsObject>,
            }
        }

    }

    export class Delete extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Delete.AsObject;
        static toObject(includeInstance: boolean, msg: Delete): Delete.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Delete, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Delete;
        static deserializeBinaryFromReader(message: Delete, reader: jspb.BinaryReader): Delete;
    }

    export namespace Delete {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class Res extends jspb.Message { 

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
            }
        }

    }

    export class Update extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Update.AsObject;
        static toObject(includeInstance: boolean, msg: Update): Update.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Update, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Update;
        static deserializeBinaryFromReader(message: Update, reader: jspb.BinaryReader): Update;
    }

    export namespace Update {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class ResPart extends jspb.Message { 
            clearAnswersList(): void;
            getAnswersList(): Array<common_answer_pb.ConceptMap>;
            setAnswersList(value: Array<common_answer_pb.ConceptMap>): ResPart;
            addAnswers(value?: common_answer_pb.ConceptMap, index?: number): common_answer_pb.ConceptMap;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): ResPart.AsObject;
            static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): ResPart;
            static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
        }

        export namespace ResPart {
            export type AsObject = {
                answersList: Array<common_answer_pb.ConceptMap.AsObject>,
            }
        }

    }

    export class Define extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Define.AsObject;
        static toObject(includeInstance: boolean, msg: Define): Define.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Define, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Define;
        static deserializeBinaryFromReader(message: Define, reader: jspb.BinaryReader): Define;
    }

    export namespace Define {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class Res extends jspb.Message { 

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
            }
        }

    }

    export class Undefine extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Undefine.AsObject;
        static toObject(includeInstance: boolean, msg: Undefine): Undefine.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Undefine, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Undefine;
        static deserializeBinaryFromReader(message: Undefine, reader: jspb.BinaryReader): Undefine;
    }

    export namespace Undefine {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getQuery(): string;
            setQuery(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                query: string,
            }
        }

        export class Res extends jspb.Message { 

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
            }
        }

    }

}
