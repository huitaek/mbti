// package: typedb.protocol
// file: common/logic.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";
import * as common_answer_pb from "../common/answer_pb";

export class LogicManager extends jspb.Message { 

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): LogicManager.AsObject;
    static toObject(includeInstance: boolean, msg: LogicManager): LogicManager.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: LogicManager, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): LogicManager;
    static deserializeBinaryFromReader(message: LogicManager, reader: jspb.BinaryReader): LogicManager;
}

export namespace LogicManager {
    export type AsObject = {
    }


    export class Req extends jspb.Message { 

        hasGetRuleReq(): boolean;
        clearGetRuleReq(): void;
        getGetRuleReq(): LogicManager.GetRule.Req | undefined;
        setGetRuleReq(value?: LogicManager.GetRule.Req): Req;

        hasPutRuleReq(): boolean;
        clearPutRuleReq(): void;
        getPutRuleReq(): LogicManager.PutRule.Req | undefined;
        setPutRuleReq(value?: LogicManager.PutRule.Req): Req;

        hasGetRulesReq(): boolean;
        clearGetRulesReq(): void;
        getGetRulesReq(): LogicManager.GetRules.Req | undefined;
        setGetRulesReq(value?: LogicManager.GetRules.Req): Req;

        getReqCase(): Req.ReqCase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Req.AsObject;
        static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Req;
        static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
    }

    export namespace Req {
        export type AsObject = {
            getRuleReq?: LogicManager.GetRule.Req.AsObject,
            putRuleReq?: LogicManager.PutRule.Req.AsObject,
            getRulesReq?: LogicManager.GetRules.Req.AsObject,
        }

        export enum ReqCase {
            REQ_NOT_SET = 0,
            GET_RULE_REQ = 1,
            PUT_RULE_REQ = 2,
            GET_RULES_REQ = 3,
        }

    }

    export class Res extends jspb.Message { 

        hasGetRuleRes(): boolean;
        clearGetRuleRes(): void;
        getGetRuleRes(): LogicManager.GetRule.Res | undefined;
        setGetRuleRes(value?: LogicManager.GetRule.Res): Res;

        hasPutRuleRes(): boolean;
        clearPutRuleRes(): void;
        getPutRuleRes(): LogicManager.PutRule.Res | undefined;
        setPutRuleRes(value?: LogicManager.PutRule.Res): Res;

        getResCase(): Res.ResCase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Res.AsObject;
        static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Res;
        static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
    }

    export namespace Res {
        export type AsObject = {
            getRuleRes?: LogicManager.GetRule.Res.AsObject,
            putRuleRes?: LogicManager.PutRule.Res.AsObject,
        }

        export enum ResCase {
            RES_NOT_SET = 0,
            GET_RULE_RES = 1,
            PUT_RULE_RES = 2,
        }

    }

    export class ResPart extends jspb.Message { 

        hasGetRulesResPart(): boolean;
        clearGetRulesResPart(): void;
        getGetRulesResPart(): LogicManager.GetRules.ResPart | undefined;
        setGetRulesResPart(value?: LogicManager.GetRules.ResPart): ResPart;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): ResPart.AsObject;
        static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): ResPart;
        static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
    }

    export namespace ResPart {
        export type AsObject = {
            getRulesResPart?: LogicManager.GetRules.ResPart.AsObject,
        }
    }

    export class GetRule extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): GetRule.AsObject;
        static toObject(includeInstance: boolean, msg: GetRule): GetRule.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: GetRule, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): GetRule;
        static deserializeBinaryFromReader(message: GetRule, reader: jspb.BinaryReader): GetRule;
    }

    export namespace GetRule {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getLabel(): string;
            setLabel(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                label: string,
            }
        }

        export class Res extends jspb.Message { 

            hasRule(): boolean;
            clearRule(): void;
            getRule(): Rule | undefined;
            setRule(value?: Rule): Res;

            getResCase(): Res.ResCase;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
                rule?: Rule.AsObject,
            }

            export enum ResCase {
                RES_NOT_SET = 0,
                RULE = 1,
            }

        }

    }

    export class PutRule extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): PutRule.AsObject;
        static toObject(includeInstance: boolean, msg: PutRule): PutRule.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: PutRule, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): PutRule;
        static deserializeBinaryFromReader(message: PutRule, reader: jspb.BinaryReader): PutRule;
    }

    export namespace PutRule {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getLabel(): string;
            setLabel(value: string): Req;
            getWhen(): string;
            setWhen(value: string): Req;
            getThen(): string;
            setThen(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                label: string,
                when: string,
                then: string,
            }
        }

        export class Res extends jspb.Message { 

            hasRule(): boolean;
            clearRule(): void;
            getRule(): Rule | undefined;
            setRule(value?: Rule): Res;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
                rule?: Rule.AsObject,
            }
        }

    }

    export class GetRules extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): GetRules.AsObject;
        static toObject(includeInstance: boolean, msg: GetRules): GetRules.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: GetRules, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): GetRules;
        static deserializeBinaryFromReader(message: GetRules, reader: jspb.BinaryReader): GetRules;
    }

    export namespace GetRules {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
            }
        }

        export class ResPart extends jspb.Message { 
            clearRulesList(): void;
            getRulesList(): Array<Rule>;
            setRulesList(value: Array<Rule>): ResPart;
            addRules(value?: Rule, index?: number): Rule;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): ResPart.AsObject;
            static toObject(includeInstance: boolean, msg: ResPart): ResPart.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: ResPart, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): ResPart;
            static deserializeBinaryFromReader(message: ResPart, reader: jspb.BinaryReader): ResPart;
        }

        export namespace ResPart {
            export type AsObject = {
                rulesList: Array<Rule.AsObject>,
            }
        }

    }

}

export class Rule extends jspb.Message { 
    getLabel(): string;
    setLabel(value: string): Rule;
    getWhen(): string;
    setWhen(value: string): Rule;
    getThen(): string;
    setThen(value: string): Rule;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Rule.AsObject;
    static toObject(includeInstance: boolean, msg: Rule): Rule.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Rule, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Rule;
    static deserializeBinaryFromReader(message: Rule, reader: jspb.BinaryReader): Rule;
}

export namespace Rule {
    export type AsObject = {
        label: string,
        when: string,
        then: string,
    }


    export class Req extends jspb.Message { 
        getLabel(): string;
        setLabel(value: string): Req;

        hasRuleDeleteReq(): boolean;
        clearRuleDeleteReq(): void;
        getRuleDeleteReq(): Rule.Delete.Req | undefined;
        setRuleDeleteReq(value?: Rule.Delete.Req): Req;

        hasRuleSetLabelReq(): boolean;
        clearRuleSetLabelReq(): void;
        getRuleSetLabelReq(): Rule.SetLabel.Req | undefined;
        setRuleSetLabelReq(value?: Rule.SetLabel.Req): Req;

        getReqCase(): Req.ReqCase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Req.AsObject;
        static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Req;
        static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
    }

    export namespace Req {
        export type AsObject = {
            label: string,
            ruleDeleteReq?: Rule.Delete.Req.AsObject,
            ruleSetLabelReq?: Rule.SetLabel.Req.AsObject,
        }

        export enum ReqCase {
            REQ_NOT_SET = 0,
            RULE_DELETE_REQ = 100,
            RULE_SET_LABEL_REQ = 101,
        }

    }

    export class Res extends jspb.Message { 

        hasRuleDeleteRes(): boolean;
        clearRuleDeleteRes(): void;
        getRuleDeleteRes(): Rule.Delete.Res | undefined;
        setRuleDeleteRes(value?: Rule.Delete.Res): Res;

        hasRuleSetLabelRes(): boolean;
        clearRuleSetLabelRes(): void;
        getRuleSetLabelRes(): Rule.SetLabel.Res | undefined;
        setRuleSetLabelRes(value?: Rule.SetLabel.Res): Res;

        getResCase(): Res.ResCase;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Res.AsObject;
        static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Res;
        static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
    }

    export namespace Res {
        export type AsObject = {
            ruleDeleteRes?: Rule.Delete.Res.AsObject,
            ruleSetLabelRes?: Rule.SetLabel.Res.AsObject,
        }

        export enum ResCase {
            RES_NOT_SET = 0,
            RULE_DELETE_RES = 100,
            RULE_SET_LABEL_RES = 101,
        }

    }

    export class Delete extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Delete.AsObject;
        static toObject(includeInstance: boolean, msg: Delete): Delete.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: Delete, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Delete;
        static deserializeBinaryFromReader(message: Delete, reader: jspb.BinaryReader): Delete;
    }

    export namespace Delete {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
            }
        }

        export class Res extends jspb.Message { 

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
            }
        }

    }

    export class SetLabel extends jspb.Message { 

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): SetLabel.AsObject;
        static toObject(includeInstance: boolean, msg: SetLabel): SetLabel.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: SetLabel, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): SetLabel;
        static deserializeBinaryFromReader(message: SetLabel, reader: jspb.BinaryReader): SetLabel;
    }

    export namespace SetLabel {
        export type AsObject = {
        }


        export class Req extends jspb.Message { 
            getLabel(): string;
            setLabel(value: string): Req;

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Req.AsObject;
            static toObject(includeInstance: boolean, msg: Req): Req.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Req, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Req;
            static deserializeBinaryFromReader(message: Req, reader: jspb.BinaryReader): Req;
        }

        export namespace Req {
            export type AsObject = {
                label: string,
            }
        }

        export class Res extends jspb.Message { 

            serializeBinary(): Uint8Array;
            toObject(includeInstance?: boolean): Res.AsObject;
            static toObject(includeInstance: boolean, msg: Res): Res.AsObject;
            static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
            static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
            static serializeBinaryToWriter(message: Res, writer: jspb.BinaryWriter): void;
            static deserializeBinary(bytes: Uint8Array): Res;
            static deserializeBinaryFromReader(message: Res, reader: jspb.BinaryReader): Res;
        }

        export namespace Res {
            export type AsObject = {
            }
        }

    }

}

export class Explanation extends jspb.Message { 

    hasRule(): boolean;
    clearRule(): void;
    getRule(): Rule | undefined;
    setRule(value?: Rule): Explanation;

    getVarMappingMap(): jspb.Map<string, Explanation.VarList>;
    clearVarMappingMap(): void;

    hasCondition(): boolean;
    clearCondition(): void;
    getCondition(): common_answer_pb.ConceptMap | undefined;
    setCondition(value?: common_answer_pb.ConceptMap): Explanation;

    hasConclusion(): boolean;
    clearConclusion(): void;
    getConclusion(): common_answer_pb.ConceptMap | undefined;
    setConclusion(value?: common_answer_pb.ConceptMap): Explanation;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Explanation.AsObject;
    static toObject(includeInstance: boolean, msg: Explanation): Explanation.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Explanation, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Explanation;
    static deserializeBinaryFromReader(message: Explanation, reader: jspb.BinaryReader): Explanation;
}

export namespace Explanation {
    export type AsObject = {
        rule?: Rule.AsObject,

        varMappingMap: Array<[string, Explanation.VarList.AsObject]>,
        condition?: common_answer_pb.ConceptMap.AsObject,
        conclusion?: common_answer_pb.ConceptMap.AsObject,
    }


    export class VarList extends jspb.Message { 
        clearVarsList(): void;
        getVarsList(): Array<string>;
        setVarsList(value: Array<string>): VarList;
        addVars(value: string, index?: number): string;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): VarList.AsObject;
        static toObject(includeInstance: boolean, msg: VarList): VarList.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: VarList, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): VarList;
        static deserializeBinaryFromReader(message: VarList, reader: jspb.BinaryReader): VarList;
    }

    export namespace VarList {
        export type AsObject = {
            varsList: Array<string>,
        }
    }

}
