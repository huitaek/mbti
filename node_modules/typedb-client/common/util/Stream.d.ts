export declare abstract class Stream<T> implements AsyncIterable<T> {
    [Symbol.asyncIterator](): AsyncIterator<T, any, undefined>;
    iterator(): AsyncIterator<T, any, undefined>;
    collect(): Promise<T[]>;
    every(callbackFn: (value: T) => unknown): Promise<boolean>;
    some(callbackFn: (value: T) => unknown): Promise<boolean>;
    filter(filter: (value: T) => boolean): Stream<T>;
    map<U>(mapper: (value: T) => U): Stream<U>;
    flatMap<U>(mapper: (value: T) => Stream<U>): Stream<U>;
    forEach(fn: (value: T) => void): Promise<void>;
    first(): Promise<T | null>;
}
export declare namespace Stream {
    export function iterable<T>(iterable: AsyncIterable<T>): Iterable<T>;
    export function array<T>(items: T[]): Array<T>;
    class Iterable<T> extends Stream<T> {
        private _provider;
        constructor(provider: AsyncIterable<T>);
        [Symbol.asyncIterator](): AsyncIterator<T, any, undefined>;
    }
    class Array<T> extends Stream<T> {
        private _array;
        constructor(array: T[]);
        [Symbol.asyncIterator](): AsyncIterator<T, any, undefined>;
    }
    export class Filtered<T> extends Stream<T> {
        private _filter;
        private _source;
        constructor(source: Stream<T>, filter: (value: T) => boolean);
        [Symbol.asyncIterator](): AsyncIterator<T, any, undefined>;
    }
    export class Mapped<T, U> extends Stream<U> {
        private _source;
        private _mapper;
        constructor(source: Stream<T>, mapper: (value: T) => U);
        [Symbol.asyncIterator](): AsyncIterator<U, any, undefined>;
    }
    export class FlatMapped<T, U, S extends Stream<U>> extends Stream<U> {
        private _source;
        private _flatMapper;
        constructor(source: Stream<T>, flatMapper: (value: T) => Stream<U>);
        [Symbol.asyncIterator](): AsyncIterator<U, any, undefined>;
    }
    export {};
}
