"use strict";
/*
 * Copyright (C) 2022 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThingImpl = void 0;
const concept_pb_1 = require("typedb-protocol/common/concept_pb");
const Thing_1 = require("../../api/concept/thing/Thing");
const RoleType_1 = require("../../api/concept/type/RoleType");
const ThingType_1 = require("../../api/concept/type/ThingType");
const ErrorMessage_1 = require("../../common/errors/ErrorMessage");
const TypeDBClientError_1 = require("../../common/errors/TypeDBClientError");
const RequestBuilder_1 = require("../../common/rpc/RequestBuilder");
const Stream_1 = require("../../common/util/Stream");
const dependencies_internal_1 = require("../../dependencies_internal");
var BAD_ENCODING = ErrorMessage_1.ErrorMessage.Concept.BAD_ENCODING;
var BAD_VALUE_TYPE = ErrorMessage_1.ErrorMessage.Concept.BAD_VALUE_TYPE;
class ThingImpl extends dependencies_internal_1.ConceptImpl {
    constructor(iid, inferred) {
        super();
        if (!iid)
            throw new TypeDBClientError_1.TypeDBClientError(ErrorMessage_1.ErrorMessage.Concept.MISSING_IID);
        this._iid = iid;
        this._inferred = inferred;
    }
    equals(concept) {
        if (concept.isType())
            return false;
        else
            return concept.asThing().iid === this._iid;
    }
    toString() {
        return `${this.className}[iid:${this._iid}]`;
    }
    get iid() {
        return this._iid;
    }
    get inferred() {
        return this._inferred;
    }
    isThing() {
        return true;
    }
    asThing() {
        return this;
    }
}
exports.ThingImpl = ThingImpl;
(function (ThingImpl) {
    class Remote extends dependencies_internal_1.ConceptImpl.Remote {
        constructor(transaction, iid, inferred, ..._) {
            super(transaction);
            if (!iid)
                throw new TypeDBClientError_1.TypeDBClientError(ErrorMessage_1.ErrorMessage.Concept.MISSING_IID);
            this._iid = iid;
            this._inferred = inferred;
        }
        equals(concept) {
            if (concept.isType())
                return false;
            else
                return concept.asThing().iid === this._iid;
        }
        toString() {
            return `${this.className}[iid:${this._iid}]`;
        }
        get iid() {
            return this._iid;
        }
        get inferred() {
            return this._inferred;
        }
        isThing() {
            return true;
        }
        asThing() {
            return this;
        }
        async delete() {
            const request = RequestBuilder_1.RequestBuilder.Thing.deleteReq(this.iid);
            await this.execute(request);
        }
        getHas(onlyKeyAttrTypeAttrTypes) {
            let isSingleAttrType = false;
            let request;
            if (typeof onlyKeyAttrTypeAttrTypes === "undefined") {
                request = RequestBuilder_1.RequestBuilder.Thing.getHasReq(this.iid, false);
            }
            else if (typeof onlyKeyAttrTypeAttrTypes === "boolean") {
                request = RequestBuilder_1.RequestBuilder.Thing.getHasReq(this.iid, onlyKeyAttrTypeAttrTypes);
            }
            else if (onlyKeyAttrTypeAttrTypes instanceof Array) {
                const attrTypesProto = onlyKeyAttrTypeAttrTypes.map((attrType) => ThingType_1.ThingType.proto(attrType));
                request = RequestBuilder_1.RequestBuilder.Thing.getHasByTypeReq(this.iid, attrTypesProto);
            }
            else {
                request = RequestBuilder_1.RequestBuilder.Thing.getHasByTypeReq(this.iid, [ThingType_1.ThingType.proto(onlyKeyAttrTypeAttrTypes)]);
                isSingleAttrType = true;
            }
            const attributes = this.stream(request).flatMap((resPart) => Stream_1.Stream.array(resPart.getThingGetHasResPart().getAttributesList()))
                .map((attrProto) => dependencies_internal_1.AttributeImpl.of(attrProto));
            if (isSingleAttrType) {
                const arg = onlyKeyAttrTypeAttrTypes;
                if (arg.isBoolean())
                    return attributes;
                else if (arg.isLong())
                    return attributes;
                else if (arg.isDouble())
                    return attributes;
                else if (arg.isString())
                    return attributes;
                else if (arg.isDateTime())
                    return attributes;
                else
                    throw new TypeDBClientError_1.TypeDBClientError(BAD_VALUE_TYPE.message(arg));
            }
            else {
                return attributes;
            }
        }
        getPlaying() {
            const request = RequestBuilder_1.RequestBuilder.Thing.getPlayingReq(this.iid);
            return this.stream(request)
                .flatMap((resPart) => Stream_1.Stream.array(resPart.getThingGetPlayingResPart().getRoleTypesList()))
                .map((res) => dependencies_internal_1.RoleTypeImpl.of(res));
        }
        getRelations(roleTypes) {
            if (!roleTypes)
                roleTypes = [];
            const request = RequestBuilder_1.RequestBuilder.Thing.getRelationsReq(this.iid, roleTypes.map((roleType) => RoleType_1.RoleType.proto(roleType)));
            return this.stream(request)
                .flatMap((resPart) => Stream_1.Stream.array(resPart.getThingGetRelationsResPart().getRelationsList()))
                .map((res) => dependencies_internal_1.RelationImpl.of(res));
        }
        async isDeleted() {
            return !(await this.transaction.concepts.getThing(this.iid));
        }
        async setHas(attribute) {
            const request = RequestBuilder_1.RequestBuilder.Thing.setHasReq(this.iid, Thing_1.Thing.proto(attribute));
            await this.execute(request);
        }
        async unsetHas(attribute) {
            const request = RequestBuilder_1.RequestBuilder.Thing.unsetHasReq(this.iid, Thing_1.Thing.proto(attribute));
            await this.execute(request);
        }
        async execute(request) {
            return (await this.transaction.rpcExecute(request, false)).getThingRes();
        }
        stream(request) {
            return this.transaction.rpcStream(request).map((res) => res.getThingResPart());
        }
    }
    ThingImpl.Remote = Remote;
    function of(thingProto) {
        switch (thingProto.getType().getEncoding()) {
            case concept_pb_1.Type.Encoding.ENTITY_TYPE:
                return dependencies_internal_1.EntityImpl.of(thingProto);
            case concept_pb_1.Type.Encoding.RELATION_TYPE:
                return dependencies_internal_1.RelationImpl.of(thingProto);
            case concept_pb_1.Type.Encoding.ATTRIBUTE_TYPE:
                return dependencies_internal_1.AttributeImpl.of(thingProto);
            default:
                throw new TypeDBClientError_1.TypeDBClientError(BAD_ENCODING.message(thingProto.getType().getEncoding()));
        }
    }
    ThingImpl.of = of;
})(ThingImpl = exports.ThingImpl || (exports.ThingImpl = {}));
