"use strict";
/*
 * Copyright (C) 2022 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConceptMapImpl = void 0;
const ErrorMessage_1 = require("../../common/errors/ErrorMessage");
const TypeDBClientError_1 = require("../../common/errors/TypeDBClientError");
const dependencies_internal_1 = require("../../dependencies_internal");
class ConceptMapImpl {
    constructor(concepts, explainables) {
        this._concepts = concepts;
        this._explainables = explainables;
    }
    concepts() {
        return this._concepts.values();
    }
    get(variable) {
        return this._concepts.get(variable);
    }
    get map() {
        return this._concepts;
    }
    get explainables() {
        return this._explainables;
    }
}
exports.ConceptMapImpl = ConceptMapImpl;
/* eslint no-inner-declarations: "off" */
(function (ConceptMapImpl) {
    var NONEXISTENT_EXPLAINABLE_CONCEPT = ErrorMessage_1.ErrorMessage.Query.NONEXISTENT_EXPLAINABLE_CONCEPT;
    var NONEXISTENT_EXPLAINABLE_OWNERSHIP = ErrorMessage_1.ErrorMessage.Query.NONEXISTENT_EXPLAINABLE_OWNERSHIP;
    function ofExplainables(proto) {
        const relations = new Map();
        proto.getRelationsMap().forEach((explainable, variable) => relations.set(variable, ofExplainable(explainable)));
        const attributes = new Map();
        proto.getAttributesMap().forEach((explainable, variable) => relations.set(variable, ofExplainable(explainable)));
        const ownerships = new Map();
        proto.getOwnershipsMap().forEach((owned, owner) => owned.getOwnedMap().forEach((explainable, attribute) => {
            ownerships.set([owner, attribute], ofExplainable(explainable));
        }));
        return new ExplainablesImpl(relations, attributes, ownerships);
    }
    function of(proto) {
        const variableMap = new Map();
        proto.getMapMap().forEach((protoConcept, resLabel) => {
            let concept;
            if (protoConcept.hasThing())
                concept = dependencies_internal_1.ThingImpl.of(protoConcept.getThing());
            else
                concept = dependencies_internal_1.TypeImpl.of(protoConcept.getType());
            variableMap.set(resLabel, concept);
        });
        return new ConceptMapImpl(variableMap, ofExplainables(proto.getExplainables()));
    }
    ConceptMapImpl.of = of;
    function ofExplainable(proto) {
        return new ExplainableImpl(proto.getConjunction(), proto.getId());
    }
    class ExplainablesImpl {
        constructor(relations, attributes, ownerships) {
            this._relations = relations;
            this._attributes = attributes;
            this._ownerships = ownerships;
        }
        relation(variable) {
            const explainable = this._relations.get(variable);
            if (!explainable)
                throw new TypeDBClientError_1.TypeDBClientError(NONEXISTENT_EXPLAINABLE_CONCEPT.message(variable));
            return explainable;
        }
        attribute(variable) {
            const explainable = this._attributes.get(variable);
            if (!explainable)
                throw new TypeDBClientError_1.TypeDBClientError(NONEXISTENT_EXPLAINABLE_CONCEPT.message(variable));
            return explainable;
        }
        ownership(owner, attribute) {
            for (const entry of this._ownerships) {
                if (entry[0][0] === owner && entry[0][1] === attribute)
                    return entry[1];
            }
            throw new TypeDBClientError_1.TypeDBClientError(NONEXISTENT_EXPLAINABLE_OWNERSHIP.message(owner, attribute));
        }
        get relations() {
            return this._relations;
        }
        get attributes() {
            return this._attributes;
        }
        get ownerships() {
            return this._ownerships;
        }
    }
    ConceptMapImpl.ExplainablesImpl = ExplainablesImpl;
    class ExplainableImpl {
        constructor(conjunction, id) {
            this._conjunction = conjunction;
            this._id = id;
        }
        get conjunction() {
            return this._conjunction;
        }
        get id() {
            return this._id;
        }
    }
    ConceptMapImpl.ExplainableImpl = ExplainableImpl;
})(ConceptMapImpl = exports.ConceptMapImpl || (exports.ConceptMapImpl = {}));
