"use strict";
/*
 * Copyright (C) 2022 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponsePartIterator = void 0;
const transaction_pb_1 = require("typedb-protocol/common/transaction_pb");
const ErrorMessage_1 = require("../common/errors/ErrorMessage");
const TypeDBClientError_1 = require("../common/errors/TypeDBClientError");
const RequestBuilder_1 = require("../common/rpc/RequestBuilder");
var MISSING_RESPONSE = ErrorMessage_1.ErrorMessage.Client.MISSING_RESPONSE;
var UNKNOWN_STREAM_STATE = ErrorMessage_1.ErrorMessage.Client.UNKNOWN_STREAM_STATE;
var ResCase = transaction_pb_1.Transaction.ResPart.ResCase;
class ResponsePartIterator {
    constructor(requestId, responseCollector, dispatcher) {
        this._requestId = requestId;
        this._responseCollector = responseCollector;
        this._dispatcher = dispatcher;
    }
    async *[Symbol.asyncIterator]() {
        while (true) {
            const next = await this.next();
            if (next != null)
                yield next;
            else
                break;
        }
    }
    async next() {
        const res = await this._responseCollector.take();
        switch (res.getResCase()) {
            case ResCase.RES_NOT_SET:
                throw new TypeDBClientError_1.TypeDBClientError(MISSING_RESPONSE.message(this._requestId));
            case ResCase.STREAM_RES_PART:
                switch (res.getStreamResPart().getState()) {
                    case transaction_pb_1.Transaction.Stream.State.DONE:
                        return null;
                    case transaction_pb_1.Transaction.Stream.State.CONTINUE:
                        this._dispatcher.dispatch(RequestBuilder_1.RequestBuilder.Transaction.streamReq(this._requestId));
                        return this.next();
                    default:
                        throw new TypeDBClientError_1.TypeDBClientError(UNKNOWN_STREAM_STATE.message(res.getStreamResPart()));
                }
            default:
                return res;
        }
    }
}
exports.ResponsePartIterator = ResponsePartIterator;
