"use strict";
/*
 * Copyright (C) 2022 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BidirectionalStream = void 0;
const transaction_pb_1 = require("typedb-protocol/common/transaction_pb");
const uuid = __importStar(require("uuid"));
const ErrorMessage_1 = require("../common/errors/ErrorMessage");
const TypeDBClientError_1 = require("../common/errors/TypeDBClientError");
const Stream_1 = require("../common/util/Stream");
const ResponseCollector_1 = require("./ResponseCollector");
const ResponsePartIterator_1 = require("./ResponsePartIterator");
var MISSING_RESPONSE = ErrorMessage_1.ErrorMessage.Client.MISSING_RESPONSE;
var UNKNOWN_REQUEST_ID = ErrorMessage_1.ErrorMessage.Client.UNKNOWN_REQUEST_ID;
class BidirectionalStream {
    constructor(stub, requestTransmitter) {
        this._requestTransmitter = requestTransmitter;
        this._responseCollector = new ResponseCollector_1.ResponseCollector();
        this._responsePartCollector = new ResponseCollector_1.ResponseCollector();
        this._stub = stub;
    }
    async open() {
        const transactionStream = await this._stub.transaction();
        this.registerObserver(transactionStream);
        this._dispatcher = this._requestTransmitter.dispatcher(transactionStream);
        this._isOpen = true;
    }
    async single(request, batch) {
        const requestId = uuid.v4();
        request.setReqId(uuid.parse(requestId));
        const responseQueue = this._responseCollector.queue(requestId);
        if (batch)
            this._dispatcher.dispatch(request);
        else
            this._dispatcher.dispatchNow(request);
        return await responseQueue.take();
    }
    stream(request) {
        const requestId = uuid.v4();
        request.setReqId(uuid.parse(requestId));
        const responseQueue = this._responsePartCollector.queue(requestId);
        const responseIterator = new ResponsePartIterator_1.ResponsePartIterator(requestId, responseQueue, this._dispatcher);
        this._dispatcher.dispatch(request);
        return Stream_1.Stream.iterable(responseIterator);
    }
    isOpen() {
        return this._isOpen;
    }
    async close(error) {
        this._isOpen = false;
        this._error = error;
        this._responseCollector.close(error);
        this._responsePartCollector.close(error);
        this._dispatcher.close();
    }
    registerObserver(transactionStream) {
        transactionStream.on("data", (res) => {
            if (!this.isOpen()) {
                return;
            }
            switch (res.getServerCase()) {
                case transaction_pb_1.Transaction.Server.ServerCase.RES:
                    this.collectRes(res.getRes());
                    return;
                case transaction_pb_1.Transaction.Server.ServerCase.RES_PART:
                    this.collectResPart(res.getResPart());
                    return;
                case transaction_pb_1.Transaction.Server.ServerCase.SERVER_NOT_SET:
                default:
                    throw new TypeDBClientError_1.TypeDBClientError(MISSING_RESPONSE.message(res));
            }
        });
        transactionStream.on("error", (err) => {
            this.close(err);
        });
        transactionStream.on("done", () => {
            this.close();
        });
    }
    collectRes(res) {
        const requestId = res.getReqId();
        const queue = this._responseCollector.get(uuid.stringify(requestId));
        if (!queue)
            throw new TypeDBClientError_1.TypeDBClientError(UNKNOWN_REQUEST_ID.message(requestId));
        queue.put(res);
    }
    collectResPart(res) {
        const requestId = res.getReqId();
        const queue = this._responsePartCollector.get(uuid.stringify(requestId));
        if (!queue)
            throw new TypeDBClientError_1.TypeDBClientError(UNKNOWN_REQUEST_ID.message(requestId));
        queue.put(res);
    }
    dispatcher() {
        return this._dispatcher;
    }
    getError() {
        return this._error;
    }
}
exports.BidirectionalStream = BidirectionalStream;
