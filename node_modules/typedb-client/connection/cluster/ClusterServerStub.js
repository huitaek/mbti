"use strict";
/*
 * Copyright (C) 2022 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterServerStub = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const fs = __importStar(require("fs"));
const cluster_service_grpc_pb_1 = require("typedb-protocol/cluster/cluster_service_grpc_pb");
const core_service_grpc_pb_1 = require("typedb-protocol/core/core_service_grpc_pb");
const TypeDBClientError_1 = require("../../common/errors/TypeDBClientError");
const TypeDBStub_1 = require("../../common/rpc/TypeDBStub");
const RequestBuilder_1 = require("../../common/rpc/RequestBuilder");
const ErrorMessage_1 = require("../../common/errors/ErrorMessage");
var CLUSTER_TOKEN_CREDENTIAL_INVALID = ErrorMessage_1.ErrorMessage.Client.CLUSTER_TOKEN_CREDENTIAL_INVALID;
function isServiceError(e) {
    return "code" in e;
}
class ClusterServerStub extends TypeDBStub_1.TypeDBStub {
    constructor(address, credential) {
        super();
        this._credential = credential;
        this._token = null;
        const stubCredentials = this.createChannelCredentials();
        this._stub = new core_service_grpc_pb_1.TypeDBClient(address, stubCredentials);
        this._clusterStub = new cluster_service_grpc_pb_1.TypeDBClusterClient(address, stubCredentials);
    }
    async open() {
        try {
            console.log(`token '${this._token}' expired. renewing...`);
            const req = RequestBuilder_1.RequestBuilder.Cluster.User.tokenReq(this._credential.username);
            this._token = await this.userToken(req);
            console.log(`token renewed to '${this._token}'`);
        }
        catch (e) {
            if (!isServiceError(e))
                throw e;
        }
    }
    createChannelCredentials() {
        const callCreds = this.createCallCredentials();
        if (this._credential.tlsRootCAPath != null) {
            const rootCert = fs.readFileSync(this._credential.tlsRootCAPath);
            return grpc_js_1.credentials.combineChannelCredentials(grpc_js_1.ChannelCredentials.createSsl(rootCert), callCreds);
        }
        else {
            return grpc_js_1.credentials.combineChannelCredentials(grpc_js_1.ChannelCredentials.createSsl(), callCreds);
        }
    }
    createCallCredentials() {
        const metaCallback = (_params, callback) => {
            const metadata = new grpc_js_1.Metadata();
            metadata.add('username', this._credential.username);
            if (this._token == null) {
                metadata.add('password', this._credential.password);
            }
            else {
                metadata.add('token', this._token);
            }
            callback(null, metadata);
        };
        return grpc_js_1.CallCredentials.createFromMetadataGenerator(metaCallback);
    }
    serversAll(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.servers_all(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve(res);
            });
        }));
    }
    usersAll(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.users_all(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve(res);
            });
        }));
    }
    usersContains(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.users_contains(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve(res.getContains());
            });
        }));
    }
    userCreate(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.users_create(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve();
            });
        }));
    }
    userPassword(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.user_password(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve();
            });
        }));
    }
    userDelete(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.user_delete(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve();
            });
        }));
    }
    databasesClusterGet(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.databases_get(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve(res);
            });
        }));
    }
    databasesClusterAll(req) {
        return this.mayRenewToken(() => new Promise((resolve, reject) => {
            this._clusterStub.databases_all(req, (err, res) => {
                if (err)
                    reject(new TypeDBClientError_1.TypeDBClientError(err));
                else
                    resolve(res);
            });
        }));
    }
    databasesCreate(req) {
        return this.mayRenewToken(() => super.databasesCreate(req));
    }
    databasesContains(req) {
        return this.mayRenewToken(() => super.databasesContains(req));
    }
    databasesAll(req) {
        return this.mayRenewToken(() => super.databasesAll(req));
    }
    databaseDelete(req) {
        return this.mayRenewToken(() => super.databaseDelete(req));
    }
    databaseSchema(req) {
        return this.mayRenewToken(() => super.databaseSchema(req));
    }
    sessionOpen(req) {
        return this.mayRenewToken(() => super.sessionOpen(req));
    }
    sessionClose(req) {
        return this.mayRenewToken(() => super.sessionClose(req));
    }
    sessionPulse(req) {
        return this.mayRenewToken(() => super.sessionPulse(req));
    }
    transaction() {
        return this.mayRenewToken(() => super.transaction());
    }
    async mayRenewToken(fn) {
        try {
            return await fn();
        }
        catch (e) {
            if (e instanceof TypeDBClientError_1.TypeDBClientError && CLUSTER_TOKEN_CREDENTIAL_INVALID === e.messageTemplate) {
                console.log(`token '${this._token}' expired. renewing...`);
                this._token = null;
                const req = RequestBuilder_1.RequestBuilder.Cluster.User.tokenReq(this._credential.username);
                this._token = await this.userToken(req);
                console.log(`token renewed to '${this._token}'`);
                try {
                    return await fn();
                }
                catch (e2) {
                    if (isServiceError(e2)) {
                        throw new TypeDBClientError_1.TypeDBClientError(e2);
                    }
                    else
                        throw e2;
                }
            }
            else
                throw e;
        }
    }
    async userToken(req) {
        return new Promise((resolve, reject) => {
            return this._clusterStub.user_token(req, (err, res) => {
                if (err)
                    reject(err);
                else
                    resolve(res.getToken());
            });
        });
    }
    stub() {
        return this._stub;
    }
    close() {
        this._stub.close();
        this._clusterStub.close();
    }
}
exports.ClusterServerStub = ClusterServerStub;
