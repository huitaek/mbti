"use strict";
/*
 * Copyright (C) 2022 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterDatabaseManager = void 0;
const ErrorMessage_1 = require("../../common/errors/ErrorMessage");
const TypeDBClientError_1 = require("../../common/errors/TypeDBClientError");
const RequestBuilder_1 = require("../../common/rpc/RequestBuilder");
const ClusterDatabase_1 = require("./ClusterDatabase");
const FailsafeTask_1 = require("./FailsafeTask");
var CLUSTER_ALL_NODES_FAILED = ErrorMessage_1.ErrorMessage.Client.CLUSTER_ALL_NODES_FAILED;
var CLUSTER_REPLICA_NOT_PRIMARY = ErrorMessage_1.ErrorMessage.Client.CLUSTER_REPLICA_NOT_PRIMARY;
var DB_DOES_NOT_EXIST = ErrorMessage_1.ErrorMessage.Client.DB_DOES_NOT_EXIST;
class ClusterDatabaseManager {
    constructor(client) {
        this._client = client;
        this._databaseManagers = Object.entries(this._client.clusterServerClients()).reduce((obj, [addr, client]) => {
            obj[addr] = client.databases;
            return obj;
        }, {});
    }
    async contains(name) {
        return await this.failsafeTask(name, ((stub, dbMgr) => dbMgr.contains(name)));
    }
    async create(name) {
        return await this.failsafeTask(name, ((stub, dbMgr) => dbMgr.create(name)));
    }
    async get(name) {
        return await this.failsafeTask(name, (async (stub, dbMgr) => {
            if (await this.contains(name)) {
                const res = await stub.databasesClusterGet(RequestBuilder_1.RequestBuilder.Cluster.DatabaseManager.getReq(name));
                return ClusterDatabase_1.ClusterDatabase.of(res.getDatabase(), this._client);
            }
            throw new TypeDBClientError_1.TypeDBClientError(DB_DOES_NOT_EXIST.message(name));
        }));
    }
    async all() {
        let errors = "";
        for (const address of Object.keys(this._databaseManagers)) {
            try {
                const res = await this._client.stub(address).databasesClusterAll(RequestBuilder_1.RequestBuilder.Cluster.DatabaseManager.allReq());
                return res.getDatabasesList().map(db => ClusterDatabase_1.ClusterDatabase.of(db, this._client));
            }
            catch (e) {
                errors += `- ${address}: ${e}\n`;
            }
        }
        throw new TypeDBClientError_1.TypeDBClientError(CLUSTER_ALL_NODES_FAILED.message(errors));
    }
    databaseManagers() {
        return this._databaseManagers;
    }
    rpcClient() {
        return this._client;
    }
    async failsafeTask(name, task) {
        const failsafeTask = new DatabaseManagerFailsafeTask(this._client, name, task);
        try {
            return await failsafeTask.runAnyReplica();
        }
        catch (e) {
            if (e instanceof TypeDBClientError_1.TypeDBClientError && CLUSTER_REPLICA_NOT_PRIMARY === e.messageTemplate) {
                return await failsafeTask.runPrimaryReplica();
            }
            else
                throw e;
        }
    }
}
exports.ClusterDatabaseManager = ClusterDatabaseManager;
class DatabaseManagerFailsafeTask extends FailsafeTask_1.FailsafeTask {
    constructor(client, database, task) {
        super(client, database);
        this._task = task;
    }
    async run(replica) {
        return this._task(this.client.stub(replica.address), this.client.clusterServerClient(replica.address).databases);
    }
}
