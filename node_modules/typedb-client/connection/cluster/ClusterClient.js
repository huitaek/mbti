"use strict";
/*
 * Copyright (C) 2022 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterClient = void 0;
const TypeDBOptions_1 = require("../../api/connection/TypeDBOptions");
const ErrorMessage_1 = require("../../common/errors/ErrorMessage");
const TypeDBClientError_1 = require("../../common/errors/TypeDBClientError");
const RequestBuilder_1 = require("../../common/rpc/RequestBuilder");
const ClusterDatabaseManager_1 = require("./ClusterDatabaseManager");
const ClusterServerClient_1 = require("./ClusterServerClient");
const ClusterServerStub_1 = require("./ClusterServerStub");
const ClusterSession_1 = require("./ClusterSession");
const ClusterUserManager_1 = require("./ClusterUserManager");
const FailsafeTask_1 = require("./FailsafeTask");
var CLUSTER_UNABLE_TO_CONNECT = ErrorMessage_1.ErrorMessage.Client.CLUSTER_UNABLE_TO_CONNECT;
class ClusterClient {
    constructor(addresses, credential) {
        this._addresses = addresses;
        this._credential = credential;
    }
    async open() {
        const serverAddresses = await this.fetchClusterServers();
        this._serverClients = {};
        const openReqs = [];
        for (const addr of serverAddresses) {
            const serverClient = new ClusterServerClient_1.ClusterServerClient(addr, this._credential);
            openReqs.push(serverClient.open());
            this._serverClients[addr] = serverClient;
        }
        await Promise.all(openReqs);
        this._userManager = new ClusterUserManager_1.ClusterUserManager(this);
        this._databaseManagers = new ClusterDatabaseManager_1.ClusterDatabaseManager(this);
        this._databases = {};
        this._isOpen = true;
        return this;
    }
    isOpen() {
        return this._isOpen;
    }
    get users() {
        return this._userManager;
    }
    get databases() {
        return this._databaseManagers;
    }
    clusterDatabases() {
        return this._databases;
    }
    session(database, type, options = TypeDBOptions_1.TypeDBOptions.cluster()) {
        if (options.readAnyReplica) {
            return this.sessionAnyReplica(database, type, options);
        }
        else {
            return this.sessionPrimaryReplica(database, type, options);
        }
    }
    sessionPrimaryReplica(database, type, options) {
        return new OpenSessionFailsafeTask(database, type, options, this).runPrimaryReplica();
    }
    sessionAnyReplica(database, type, options) {
        return new OpenSessionFailsafeTask(database, type, options, this).runAnyReplica();
    }
    clusterServerClients() {
        return this._serverClients;
    }
    clusterServerClient(address) {
        return this._serverClients[address];
    }
    clusterServerAddresses() {
        return Object.keys(this._serverClients);
    }
    stub(address) {
        return this._serverClients[address].stub();
    }
    isCluster() {
        return true;
    }
    asCluster() {
        return this;
    }
    async close() {
        if (this._isOpen) {
            this._isOpen = false;
            for (const serverClient of Object.values(this._serverClients)) {
                await serverClient.close();
            }
        }
    }
    async fetchClusterServers() {
        for (const address of this._addresses) {
            try {
                console.info(`Fetching list of cluster servers from ${address}...`);
                const clusterStub = new ClusterServerStub_1.ClusterServerStub(address, this._credential);
                await clusterStub.open();
                const res = await clusterStub.serversAll(RequestBuilder_1.RequestBuilder.Cluster.ServerManager.allReq());
                const members = res.getServersList().map(x => x.getAddress());
                console.info(`The cluster servers are ${members}`);
                return members;
            }
            catch (e) {
                console.error(`Fetching cluster servers from ${address} failed.`, e);
            }
        }
        throw new TypeDBClientError_1.TypeDBClientError(CLUSTER_UNABLE_TO_CONNECT.message(this._addresses.join(",")));
    }
}
exports.ClusterClient = ClusterClient;
class OpenSessionFailsafeTask extends FailsafeTask_1.FailsafeTask {
    constructor(database, type, options, client) {
        super(client, database);
        this._type = type;
        this._options = options;
    }
    run(replica) {
        const session = new ClusterSession_1.ClusterSession(this.client, replica.address);
        return session.open(replica.address, this.database, this._type, this._options);
    }
}
